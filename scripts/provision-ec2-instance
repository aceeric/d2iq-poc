#!/usr/bin/env bash
#
# Provisions an EC2 instance. This script is intended to be run on any Linux
# environment with the AWS CLI installed. The script uses AMIs owned by account
# 1177-5186-3401 that have been shared with your account. (This account number is
# hard-coded into the script.)
#

short_opts=hds:v:o:
long_opts=help,dry-run,ssh-keys:,vol-size:,owner:
script_name=$(basename "$0")

dry_run=0
ssh_keys=
vol_size=30
owner=117751863401
scriptdir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

function usage() {
  awk '{if (NR!=1) print substr($0,5)}' <<< '
    Creates a SigIO EC2 instance using the AWS CLI "ec2 run-instances" command.

    The script expects non-expired Kion credentials (either in the env or in
    ~/.aws/credentials.) All script params except the --dry-run param are positional.

    Usage: provision-ec2-instance [--dry-run] [--ssh-keys prefix] [--vol-size n] -- [VPC name]
           [subnet name] [security group name] [AMI name] [instance type]
           [instance name] [instance profile name]

    Options:
    
      -h,--help           Prints this help and exits
      -d,--dry-run        Causes the script to print the AWS identifiers that the script
                          looked up based on positional params, and then exit. It is
                          recommended to always use --dry-run first to validate the lookups
                          worked as expected
      -s,--ssh-keys path  Creates the instance with a cloud-config file with public and private
                          keys from the specified path to configure the ~/.ssh directory in the
                          EC2 instance. The script assumes that "~" in your AWS workstation
                          resolves to the identical physical path in the EC2 instance (e.g.
                          /home/yoursid)
      -v,--vol-size n     Specifies the size of the disk. Defaults to 30. Value is interpreted
                          as gigs. E.g. "30" means "30 gigs"
      -o,--owner n        Specifies the image owner. Default is 117751863401 if not specified

    Positional params:

      VPC name               E.g. "project-vpc"
      Subnet name            Subnet within VPC. E.g. "us-east-subnet-3"
      Security group name    E.g. "devcraft-networking-SecurityGroup-Q6P991Z0L3X6"
      AMI name               The AMI name. Note: the "eVo_..." AMIs appear to be rebuilt daily
                             so the script interprets the AMI name parameter as "starts with"
                             and owned by ID 117751863401. E.g. "eVo_AMI_CentOS7". The
                             script will look up a matching full name which will likely be
                             different on a day-to-day basis.
      Instance type          E.g. "t2.micro"
      Instance name          The name you assign to the instance, e.g. "my-test-instance"
      Instance profile name  The eVo profile, probably "evoforge-user"

    Example:

    provision-ec2-instance\
      --dry-run \
      --vol-size 50 \
      --ssh-keys ~/.ssh/id_ed25519 \
      project-vpc \
      us-east-subnet-3 \
      devcraft-networking-SecurityGroup-Q6P991Z0L3X6 \
      eVo_AMI_CentOS7 \
      t2.micro \
      esace-test2 \
      evoforge-user

    Performs a dry run:

    Creates an instance in the "project_vpc" VPC, and within that the "us_east_subnet_2" subnet.
    Assigns the instance to the "devcraft-networking-SecurityGroup-Q6P991Z0L3X6" security
    group. Uses an AMI starting with "eVo_AMI_CentOS7". Depending on the day, the actual
    AMI will be something like "eVo_AMI_CentOS7-v1.7.3-202207060526-packerbuilt". Uses instance
    type "t2.micro" and names the instance "esace-test2". Assigns instance profile "evoforge-user"
    to the instance. Populates the ~/.ssh directory in the new instance with "id_ed25519",
    "id_ed25519.pub", and "authorized_keys" (from id_ed25519.pub).

    All of the human readable identifiers are things you should be able to see in the AWS console.
    '
}

# this is a cloud config template "file". Values will be interpolated into it below
# and the iterpolated result written to a temp file for mounting into the instance.
cloud_config_template='#cloud-config

users:
- name: USER
  sudo: ALL=(ALL) NOPASSWD:ALL
  ssh_authorized_keys:
  - PUBKEYCONTENT

write_files:
- path: PRIVKEYPATH
  permissions: "0600"
  encoding: base64
  content: PRIVKEYCONTENT
- path: PUBKEYPATH
  content: PUBKEYCONTENT
  permissions: "0644"
runcmd:
- "chown -R USER:USER /home/USER"
'

#
# Creates a cloud-config.yaml file.
#
# args
# - $1 - the directory to write the output file to
# 
# vars:
# - ssh_keys               Value of the --ssh-keys arg
# - cloud_config_template  The template
# - $USER                  Env var
#
function gen_cloud_config() {
  echo "generating cloud config file: $1/cloud-config.yaml"
  local pubkey=$(cat "$ssh_keys.pub")
  local privkey=$(base64 -w 0 "$ssh_keys")
  echo "$cloud_config_template" | sed \
    -e "s|USER|${USER#*\\}|g" \
    -e "s|PRIVKEYPATH|/home/${USER#*\\}/.ssh/$(basename $ssh_keys)|g" \
    -e "s|PUBKEYPATH|/home/${USER#*\\}/.ssh/$(basename $ssh_keys).pub|g" \
    -e "s|PRIVKEYCONTENT|$privkey|g" \
    -e "s|PUBKEYCONTENT|$pubkey|g" \
    >| $1/cloud-config.yaml
}

#
# Options parser helper only called by parse_args
#
function opt_val() {
  opt="$1"
  if [[ "$opt" == =* ]]; then
    echo "${opt:1}"
  else
    echo "$opt"
  fi
}

#
# Parses the command line
#
function parse_args() {
  local parsed
  parsed=$(getopt --options $short_opts --longoptions $long_opts -n $script_name -- "$@")
  
  if [[ "$?" -ne 0 ]]; then
    exit 1
  fi

  eval set -- "$parsed"

  while true; do
    case "$1" in
      -h|--help)
        usage
        exit 1
        ;;
      -v|--vol-size)
        vol_size=$(opt_val "$2")
        shift 2
        ;;
      -o|--owner)
        owner=$(opt_val "$2")
        shift 2
        ;;
      -s|--ssh-keys)
        ssh_keys=$(opt_val "$2")
        shift 2
        ;;
      -d|--dry-run)
        dry_run=1
        shift 1
        ;;
      --)
        shift
        break
        ;;
    esac
  done

  if [[ $# -ne 7 ]]; then
    echo "$script_name: incorrect positional parameters"
    exit 1
  fi

  # assign positional params to script vars

  VPC_NAME="$1"
  SUBNET_NAME="$2"
  SECURITY_GRP_NAME="$3"
  AMI_NAME="$4"
  AMI_NAME_FOUND=
  INSTANCE_TYPE="$5"
  INSTANCE_NAME="$6"
  INSTANCE_PROFILE_NAME="$7"
}

# Entry point

parse_args "$@"

# debug
# echo "VPC_NAME=$VPC_NAME"
# echo "SUBNET_NAME=$SUBNET_NAME"
# echo "SECURITY_GRP_NAME=$SECURITY_GRP_NAME"
# echo "AMI_NAME=$AMI_NAME"
# echo "INSTANCE_TYPE=$INSTANCE_TYPE"
# echo "INSTANCE_NAME=$INSTANCE_NAME"
# echo "INSTANCE_PROFILE_NAME=$INSTANCE_PROFILE_NAME"
# echo "DRY_RUN=$dry_run"
# echo "SSH_KEYS=$ssh_keys"
# echo "VOL_SIZE=$vol_size"
# exit

# if --ssh-keys arg provided, validate the arg

if [[ ! -z "$ssh_keys" ]]; then
  if [[ ! -f "$ssh_keys" ]] || [[ ! -f "$ssh_keys.pub" ]]; then
    echo "based on --ssh-keys arg, expected two files $ssh_keys and $ssh_keys.pub but did not find either/both"
    exit 1
  fi
fi

echo "checking credentials"
if ! aws sts get-caller-identity &>/dev/null; then
  echo "can't establish AWS identity - possibly using stale credentials?..."
  exit 1
fi

# get the full AMI name from the "starts with" positional param

echo "looking up AMI name starting with $AMI_NAME"
images=$(aws ec2 describe-images --owners $owner --query 'Images[*].Name' --output text)
images=($images)
for image in "${images[@]}"; do
  if [[ $image == $AMI_NAME* ]]; then
    AMI_NAME_FOUND=$image
    break
  fi
done

# look up AWS IDs for all human readable values

echo "looking up exact AMI name $AMI_NAME_FOUND"
AMI_ID=$(aws ec2 describe-images --filter "Name=name,Values=$AMI_NAME_FOUND"\
         --query 'Images[0].ImageId' --output text)

echo "looking up VPC $VPC_NAME"
VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=$VPC_NAME"\
         --query 'Vpcs[0].VpcId' --output text)

echo "looking up subnet $SUBNET_NAME"
SUBNET_ID=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" "Name=tag:Name,Values=$SUBNET_NAME"\
            --query 'Subnets[0].SubnetId' --output text)

echo "looking up security group $SECURITY_GRP_NAME"
SECURITY_GRP_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=$SECURITY_GRP_NAME"\
                  --query 'SecurityGroups[0].GroupId' --output text)

echo "instance creation params:"
echo " VPC_NAME=$VPC_NAME"
echo " VPC_ID=$VPC_ID"
echo " SUBNET_NAME=$SUBNET_NAME"
echo " SUBNET_ID=$SUBNET_ID"
echo " SECURITY_GRP_NAME=$SECURITY_GRP_NAME"
echo " SECURITY_GRP_ID=$SECURITY_GRP_ID"
echo " AMI_NAME=$AMI_NAME"
echo " AMI_NAME_FOUND=$AMI_NAME_FOUND"
echo " AMI_ID=$AMI_ID"
echo " INSTANCE_TYPE=$INSTANCE_TYPE"
echo " INSTANCE_NAME=$INSTANCE_NAME"
echo " INSTANCE_PROFILE_NAME=$INSTANCE_PROFILE_NAME"
echo " SSH_KEYS=$ssh_keys"
echo " VOL_SIZE=$vol_size"

if [[ dry_run -eq 1 ]]; then
  exit
fi

echo "creating instance $INSTANCE_NAME"

if [[ ! -z "$ssh_keys" ]]; then
  tmpdir=$(mktemp -d)
  gen_cloud_config $tmpdir
  aws ec2 run-instances\
   --block-device-mappings '[{"DeviceName":"/dev/sda1","Ebs":{"VolumeSize":'$vol_size',"DeleteOnTermination":true}}]'\
   --image-id $AMI_ID\
   --instance-type $INSTANCE_TYPE\
   --security-group-ids $SECURITY_GRP_ID\
   --iam-instance-profile Name=$INSTANCE_PROFILE_NAME\
   --subnet-id $SUBNET_ID\
   --count 1\
   --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value='$INSTANCE_NAME'},{Key=evogroup,Value=sigio},{Key=nostartup,Value=true},{Key=owner,Value='${USER#*\\}'}]'\
   --user-data file://$tmpdir/cloud-config.yaml \
   >| /tmp/run-instance.result.json
else
  aws ec2 run-instances\
   --block-device-mappings '[{"DeviceName":"/dev/sda1","Ebs":{"VolumeSize":'$vol_size',"DeleteOnTermination":true}}]'\
   --image-id $AMI_ID\
   --instance-type $INSTANCE_TYPE\
   --security-group-ids $SECURITY_GRP_ID\
   --iam-instance-profile Name=$INSTANCE_PROFILE_NAME\
   --subnet-id $SUBNET_ID\
   --count 1\
   --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value='$INSTANCE_NAME'},{Key=evogroup,Value=sigio},{Key=nostartup,Value=true},{Key=owner,Value='${USER#*\\}'}]'\
   >| /tmp/run-instance.result.json
fi

if [[ $? -ne 0 ]]; then
  echo "instance creation failed - stopping"
  exit 1
fi

# getting instance ID has some complexity to deal with cases where there are multiple instances
# with the same name, and one or more are terminated but we're looking for the one that is running...

echo "getting the instance ID"
INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=$INSTANCE_NAME"\
              --query 'Reservations[*].Instances[?!contains(State.Name, '"'terminated'"')].InstanceId'\
              --output text)

echo "waiting for instance $INSTANCE_ID to be ready"
while true; do
  INSTANCE_STATUS=$(aws ec2 describe-instance-status --instance-ids $INSTANCE_ID\
                    --query 'InstanceStatuses[0].InstanceStatus.Status' --output text)
  if [[ $INSTANCE_STATUS == "ok" ]]; then
    break
  fi
  echo "...sleeping 20 seconds"
  sleep 20s
done
echo "instance is ready"

echo "getting instance hostname"
INSTANCE_HOSTNAME=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID\
                    --query 'Reservations[0].Instances[0].PrivateDnsName' --output text)

echo "getting instance IP address"
INSTANCE_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID\
                    --query 'Reservations[0].Instances[0].PrivateIpAddress' --output text)

echo "To set the IP address env var in your shell: export INSTANCE_IP=$INSTANCE_IP"
echo "you can now ssh in to the server:"
echo
echo "ssh -o 'StrictHostKeyChecking no' ${USER#*\\}@$INSTANCE_HOSTNAME"
